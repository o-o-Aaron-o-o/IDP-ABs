
  // Hardware Connections (Breakoutboard to Arduino):
  // -5V = 5V (3.3V is allowed)
  // -GND = GND
  // -SDA = A4 (or SDA)
  // -SCL = A5 (or SCL)
  // -INT = Not connected







void Oxi_Init()
{
  if (!Pulsoxi.begin(Wire, I2C_SPEED_FAST))                          // Use default I2C port, 400kHz speed
  {
    Serial.println("MAX30105 was not found. Please check wiring/power. ");
    while (1);
  }

  //Setup to sense a nice looking saw tooth on the plotter

  byte ledBrightness = 0x32;                                       //Options: 0=Off to 255=50mA
  byte sampleAverage = 8;                                          //Options: 1, 2, 4, 8, 16, 32
  byte ledMode = 2;                                                //Options: 1 = Red only, 2 = Red + IR, 3 = Red + IR + Green
  int sampleRate = 3200;                                           //Options: 50, 100, 200, 400, 800, 1000, 1600, 3200
  int pulseWidth = 411;                                            //Options: 69, 118, 215, 411
  int adcRange = 4096;                                             //Options: 2048, 4096, 8192, 16384

  Pulsoxi.setup(ledBrightness, sampleAverage, ledMode, sampleRate, pulseWidth, adcRange);          //Configure sensor with these settings

}




void loop_oxi() 
{
  
  static int Del_IR[BUFFER_SIZE_OXI] = {0}, Del_R[BUFFER_SIZE_OXI] = {0};              //Arrays, die für das Löschen der Zeichnung der Sensordaten genutzt werden 

  static float DC_IR = 0.0, DC_R = 0.0;                                  //Variablen für die DC-Anteile des Oxi-Signals
  static float AC_IR = 0.0, AC_R = 0.0, Z = 1.00;                        //Variablen für die DC-Anteile des Oxi-Signals und die Z - Zwischenwertvariable für die Formel der Sauerstoffsätigung
  static int BpmFlag = 0;                                                //Variable, die bei der Peakdetection hilft
  static int ArrayFuellung = 0;                                       //Variabe, die zählt wie weit die Zeichen-arrays aufgefüllt sind                                          



  float letztes_DC_IR = 0.0, letztes_DC_R = 0.0;                                  
  float letztes_AC_IR = 0.0, letztes_AC_R = 0.0;
  
  
  static int Max_IR = 190000;
  static int Min_IR = 185000;
  static int Max_R = 210000;
  static int Min_R = 190000;



  bool Flag_Sauerstoff_OK = false;



  static char SauerstoffsaettigungsBuchstaben[50] = {0};                 //Array, womit die SpO2- und Bpm-Daten auf dem Display ausgegeben werden  





  int IR_Messung = Pulsoxi.getIR();                                      //Erfassen des Oxi-Infrarot-Signals

  letztes_DC_IR = DC_IR;

  DC_IR = (1 - GLATTUNG_IR) * DC_IR + GLATTUNG_IR * IR_Messung;          //Berechnen des DC-Wertes / Mittelwertes des Infrarot-Signals des Oximeters


  IR_Messung -= DC_IR;                                                   //Rausnahme des Mittelwertes (DC-Wertes) aus dem Infrarot-Signals


  letztes_AC_IR = AC_IR;

  AC_IR = sqrt(GLATTUNG_IR * pow(IR_Messung, 2) + (1 - GLATTUNG_IR) * pow(AC_IR, 2));     //Berechnung des AC-Wertes des Infrarot-Signals


  Serial.print(" RohIR:");  	                                            //
  Serial.print(IR_Messung);                                               //
  Serial.print(" DCIR:");                                                 //
  Serial.print(DC_IR);                                                    // DEBUGGING
  Serial.print(" ACIR:");                                                 //
  Serial.print(AC_IR);                                                    //




  int R_Messung = Pulsoxi.getRed();                                       //Erfassen des Oxi-Infrarot-Signals

  letztes_DC_R = DC_R;
  
  DC_R = (1 - GLATTUNG_R) * DC_R + GLATTUNG_R * R_Messung;                //Berechnen des DC-Wertes / Mittelwertes des Rot-Signals des Oximeters


  R_Messung -= DC_R;                                                      //Rausnahme des Mittelwertes (DC-Wertes) aus dem Rot-Signals


  letztes_AC_R;

  AC_R = sqrt(GLATTUNG_R * pow(R_Messung, 2) + (1 - GLATTUNG_R) * pow(AC_R, 2));      //Berechnung des AC-Wertes des Rot-Signals
  
 
  Serial.print(" RohR:");  	                                            //
  Serial.print(R_Messung);   	                                          //
  Serial.print(" DCR:");  	                                            //
  Serial.print(DC_R);  	                                                // DEBUGGING
  Serial.print(" ACR:");  	                                            //
  Serial.print(AC_R);  	                                                //

  if((AC_R * DC_IR) != 0) 
    Z = (AC_IR * DC_R) / (AC_R * DC_IR);                                                //Berechnung des Z-Wertes für die Formel der Sauerstoffsättigung

  float SpO2 = (-45.06*Z + 30.354)*Z + 94.845;                          //Berechnen der Sauerstoffsätigung




  //Konfidenzintervalle, ob Finger drauf ist
  if((abs(DC_IR - letztes_DC_IR) <= 100) && (abs(DC_R - letztes_DC_R) <= 100) && (SpO2 > 85) && (IR_Messung + DC_IR >= 50000)) 
    Flag_Sauerstoff_OK = true;
  else
    Flag_Sauerstoff_OK = false;


  Serial.print("            Z: ");                                      //
  Serial.print(Z);                                                      // DEBUGGING
  Serial.print("          SPO2: ");                                     //
  Serial.print(SpO2);                                                 //

  static const byte RATE_SIZE = 4; //Increase this for more averaging. 4 is good.
  static byte rates[RATE_SIZE]; //Array of heart rates
  static byte rateSpot = 0;
  static long lastBeat = 0; //Time at which the last beat occurred

  static float beatsPerMinute = 0.0;
  static int beatAvg = 0;




  if(Flag_Sauerstoff_OK == true)                         //Schauen ob die Signalwerte in einem logischen Rahmen, für die Berechnung der Bpm und der Zeichnung sind
  {

	Line_IR(DC_IR);
	Line_R(DC_R);


  




    if (checkForBeat(IR_Messung + DC_IR) == true)
    {
      //We sensed a beat!
      long delta = millis() - lastBeat;
      lastBeat = millis();

      beatsPerMinute = 60 / (delta / 1000.0);

      if (beatsPerMinute < 255 && beatsPerMinute > 20)
      {
        rates[rateSpot++] = (byte)beatsPerMinute; //Store this reading in the array
        rateSpot %= RATE_SIZE; //Wrap variable

        //Take average of readings
        beatAvg = 0;
        for (byte x = 0 ; x < RATE_SIZE ; x++)
          beatAvg += rates[x];
        beatAvg /= RATE_SIZE;
      }
    }
  }


  Serial.print("       BPM: ");
  Serial.print(beatsPerMinute);
  Serial.print("    Avg BPM: ");
  Serial.println(beatAvg);




    if(Flag_Sauerstoff_OK == true)
    {
      snprintf(SauerstoffsaettigungsBuchstaben, sizeof(SauerstoffsaettigungsBuchstaben), "SpO2: % .1f  Bpm: -- ", SpO2); //Reinschreiben des Textes und der Werte in das Wortarray
      digitalWrite(LEDG, LOW);
      digitalWrite(LEDR, HIGH);
    }
    else
    {
      snprintf(SauerstoffsaettigungsBuchstaben, sizeof(SauerstoffsaettigungsBuchstaben), "SpO2: --  Bpm: -- "); //Reinschreiben des Textes und der Werte in das Wortarray
      digitalWrite(LEDR, LOW);
      digitalWrite(LEDG, HIGH);
    }

    LCD_WriteString(SauerstoffsaettigungsBuchstaben, 10, 110, colViolett, colLightBlue, 0);                                   //Zeichnen des Wortarrays









}















int FindMax(int maxArray[])
{
  int maximum = maxArray[0];

  for(int i = 1; i < BUFFER_SIZE_OXI; i++)
  {
    if (maxArray[i] > maximum) 
      maximum = maxArray[i];
  }
    

  return maximum;

}



int FindMin(int minArray[])
{
  int minimum = minArray[0];

  for(int j = 1; j < BUFFER_SIZE_OXI; j++)
  {
    if (minArray[j] <= minimum) 
      minimum = minArray[j];
  }
    

  return minimum;

}








void Line_R()
{
static int MaX = 200300;
	
	
  if(hi > MaX)
  {
	  MiN = MiN + (hi - MaX);
	  MaX = hi;
  }
  
  
	static int MiN = 200000;
	
	
  if(hi < MiN)
  {
	  MaX = MaX - (MiN - hi);
	  MiN = hi;

  }
	static int del[160] = {0};
	static int counter = 0;
	static int lastPixel = 50;
	
	gbham(counter, del[counter], counter + 1, del[counter + 1], colLightBlue);
	
	
	int Pixel1 = map(hi, MiN, MaX, 100, 0);
	
	gbham(counter, lastPixel, counter + 1, Pixel1, colBlack);
	
	del[counter] = Pixel1;
  lastPixel = Pixel1;
	
	counter++;
	
	if(counter >= 158)
		counter = 0;

}




void Line_IR(int hi)
{
	static int MaX = 200300;
	
	
  if(hi > MaX)
  {
	  MiN = MiN + (hi - MaX);
	  MaX = hi;
  }
  
  
	static int MiN = 200000;
	
	
  if(hi < MiN)
  {
	  MaX = MaX - (MiN - hi);
	  MiN = hi;

  }
	static int del[160] = {0};
	static int counter = 0;
	static int lastPixel = 50;
	
	gbham(counter, del[counter], counter + 1, del[counter + 1], colLightBlue);
	
	
	int Pixel1 = map(hi, MiN, MaX, 100, 0);
	
	gbham(counter, lastPixel, counter + 1, Pixel1, colBlack);
	
	del[counter] = Pixel1;
  lastPixel = Pixel1;
	
	counter++;
	
	if(counter >= 158)
		counter = 0;
	
}

